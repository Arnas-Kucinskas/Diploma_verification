@page "/diploma"
@using Nethereum.Metamask.Blazor.Server.DB_Models;
@using  Nethereum.Metamask.Blazor.Server.DAL;
@inject DiplomaService objDiplomaService;
@inject IJSRuntime jsRuntime;
@inject MetamaskService metamaskService;
@inject MetamaskInterceptor metamaskInterceptor;
@using Nethereum.Web3;
@using Nethereum.Hex.HexTypes;
@using Nethereum.Metamask.Blazor.Server.Classes
@using Nethereum.Hex.HexConvertors.Extensions;
@using Nethereum.Contracts;
@using Nethereum.Web3.Accounts;

<NavLink class="nav-link" href="AddDiploma">
	<span class="oi oi-plus" aria-hidden="true"></span> Add New
</NavLink>
<div class="row">
	<div class="col-md-4">
		<div class="form-group">
			<input type="button" class="btn btn-primary" @onclick="@VerifyDoccuments" value="Verify Doccuments" />
		</div>
	</div>
</div>

<h1>Diplomas waiting for verification</h1>
@if (objDiploma == null)
{
	<p><em>Loading...</em></p>
}
else
{
	<table class="table">
		<thead>
			<tr>
				<th>Diploma ID</th>
				<th>Name</th>
				<th>Last Name</th>
				<th>Studies Programe</th>
				<th>Studies Direction</th>
				<th>Hash</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var dip in objDiploma)
			{
				<tr>
					<td>@dip.ID</td>
					<td>@dip.Name</td>
					<td>@dip.LastName.</td>
					<td>@dip.StudiesProgram</td>
					<td>@dip.Studiesdirection</td>
					<td>@dip.Hash</td>
					<td>
						<a class="nav-link" href="EditDiploma/@dip.ID">
							<span class="oi oi-pencil" aria-hidden="true"></span> Edit
						</a>
						<a class="nav-link" href="DeleteDiploma/@dip.ID">
							<span class="oi oi-pencil" aria-hidden="true"></span> Delete
						</a>
					</td>
				</tr>
			}
		</tbody>
	</table>
}

@code {
	List<Diploma_model> objDiploma;
	protected override async Task OnInitializedAsync()
	{
		objDiploma = await Task.Run(() => objDiplomaService.GetAllDiplomasInQueue());
	}
	protected async Task VerifyDoccuments()
	{
		bool EthereumEnabled = await metamaskService.EnableEthereumAsync();
		string selectedAccount = "";
		List<byte[]> hashesList = new List<byte[]>();

		if (EthereumEnabled)
		{
			selectedAccount = await metamaskService.GetSelectedAccount();
		}
		else
		{
			//??
		}

		try
		{
			var url = "https://ropsten.infura.io/v3/75230d7a7f1547fcbb12f3707a6bbe44";
			var privateKey = "8AB6C6C1CF1B2D4AD8781D1B16F7CE517E8BDBE4BF1822577FA507702E58D9A3";
			var account = new Account(privateKey);
			var web3 = new Nethereum.Web3.Web3(account, url);
			web3.Client.OverridingRequestInterceptor = metamaskInterceptor;
			web3.TransactionManager.DefaultGas = 1000000;
			string abi = @"[
	{
		'inputs': [
			{
				'internalType': 'address',
				'name': 'newOwner',
				'type': 'address'
			}
		],
		'name': 'ChangeOwner',
		'outputs': [],
		'stateMutability': 'nonpayable',
		'type': 'function'
	},
	{
		'inputs': [
			{
				'internalType': 'address payable',
				'name': 'receiver',
				'type': 'address'
			}
		],
		'name': 'DeleteContract',
		'outputs': [],
		'stateMutability': 'nonpayable',
		'type': 'function'
	},
	{
		'inputs': [],
		'stateMutability': 'nonpayable',
		'type': 'constructor'
	},
	{
		'anonymous': false,
		'inputs': [
			{
				'indexed': false,
				'internalType': 'address',
				'name': 'sender',
				'type': 'address'
			}
		],
		'name': 'FallBackCalled',
		'type': 'event'
	},
	{
		'anonymous': false,
		'inputs': [
			{
				'indexed': false,
				'internalType': 'bytes32[]',
				'name': 'dataHash',
				'type': 'bytes32[]'
			}
		],
		'name': 'StoreEvent',
		'type': 'event'
	},
	{
		'inputs': [
			{
				'internalType': 'bytes32[]',
				'name': 'hashArray',
				'type': 'bytes32[]'
			}
		],
		'name': 'StoreHashes',
		'outputs': [],
		'stateMutability': 'nonpayable',
		'type': 'function'
	},
	{
		'stateMutability': 'nonpayable',
		'type': 'fallback'
	},
	{
		'inputs': [],
		'name': 'owner',
		'outputs': [
			{
				'internalType': 'address',
				'name': '',
				'type': 'address'
			}
		],
		'stateMutability': 'view',
		'type': 'function'
	}
]";

			var contract = web3.Eth.GetContract(abi, "0x3c96A679dC4713599b4EDe9F2609770782FCc023");
			var function = contract.GetFunction("StoreHashes");
			foreach (var item in objDiploma)
			{
				hashesList.Add(item.Hash.HexToByteArray());
			}
			var result = await function.SendTransactionAsync(selectedAccount, hashesList);

			//TransactionHash = await web3.Eth.GetEtherTransferService().TransferEtherAsync("0x13f022d72158410433cbd66f5dd8bf6d2d129924", 0.001m);
		}
		catch (Exception ex)
		{
			//ErrorTransferMessage = ex.Message;
		}

		//Nethereum nth = new Nethereum();

		Console.WriteLine("aa");
		//objDiplomaService.UpdateDiploma(objDiploma);
		//NavigationManager.NavigateTo("Diploma");
	}
}
